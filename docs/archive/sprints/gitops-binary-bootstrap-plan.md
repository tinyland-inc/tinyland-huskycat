# GitOps Binary + Hooks Bootstrap Implementation Plan

**Status**: Sprint 9 Planning
**Date**: December 6, 2025
**Priority**: High (Critical GitOps/IaC Use Case)

---

## Executive Summary

This plan outlines the development needed to provide a seamless GitOps/IaC validation experience via binary installation with automatic git hooks. The goal is a **single-command bootstrap** that enables comprehensive GitLab CI, Auto-DevOps, Helm, K8s, and Terraform validation in any GitOps repository.

**Vision**:
```bash
# User downloads binary
curl -L -o ~/.local/bin/huskycat <release-url>
chmod +x ~/.local/bin/huskycat

# Single bootstrap command
cd /path/to/gitops-repo
huskycat bootstrap

# Now enjoys automatic validation on every commit/push:
#  GitLab CI schema validation
#  Auto-DevOps compliance checking
#  Helm chart validation
#  Kubernetes manifest validation
#  Terraform formatting
#  Ansible linting
```

---

## Current State Analysis

### What Works 

1. **GitLab CI Validation in Pre-Push Hook**
   - File: `.githooks/pre-push:50-66`
   - Auto-detects `.gitlab-ci.yml`
   - Runs `ci-validate` command
   -  Already implemented and working

2. **Auto-Detection of GitOps Files**
   - `ci-validate` auto-detects GitLab CI files
   - `auto-devops` auto-detects Helm charts, K8s manifests
   - ValidationEngine auto-validates Terraform (`.tf`), Ansible (`playbooks/`)
   -  Detection logic exists

3. **Install Command**
   - File: `src/huskycat/commands/install.py`
   - Copies binary to `~/.local/bin/huskycat`
   - Can optionally call `setup-hooks`
   -  Basic installation works

4. **Setup-Hooks Command**
   - File: `src/huskycat/commands/hooks.py`
   - Configures `git config core.hooksPath .githooks`
   -  Git hooks setup works

### What's Missing 

1. **Auto-DevOps Validation NOT in Hooks**
   - Helm chart validation not run automatically
   - K8s manifest validation not run automatically
   - Only runs via manual `huskycat auto-devops` command

2. **No Binary Fallback in Hooks**
   - Hooks use UV exclusively: `uv run python -m src.huskycat`
   - No fallback to binary: `huskycat` command
   - **Catch-22**: Can't dogfood binary mode in own repo

3. **No GitOps Repo Auto-Detection**
   - Hooks don't detect if repo is GitOps-focused
   - Don't enable GitOps-specific validations automatically
   - User must manually configure

4. **No Binary-Managed Hook Updates**
   - Binary doesn't create/update hook files
   - Binary doesn't inject itself into hooks
   - Each binary update requires manual hook reconfiguration

5. **No Single Bootstrap Command**
   - No `huskycat bootstrap` command (exists but unclear what it does)
   - User must run multiple commands:
     - `huskycat install`
     - `huskycat setup-hooks`
     - Manual hook configuration

6. **No Hook Templates for Binary Mode**
   - `.githooks/` hooks are UV-specific
   - No binary-compatible hook templates
   - No auto-generation of hooks

---

## Gap Analysis

### Critical Gaps

| Gap | Impact | Priority | Effort |
|-----|--------|----------|--------|
| **1. Auto-DevOps not in hooks** | GitOps repos don't get automatic Helm/K8s validation | ðŸ”´ Critical | 1-2 days |
| **2. Binary fallback in hooks** | Binary mode can't be used for hooks | ðŸ”´ Critical | 1 day |
| **3. Binary-managed hooks** | Binary can't update hooks automatically | ðŸ”´ Critical | 2-3 days |
| **4. GitOps auto-detection** | No automatic enablement of GitOps validations | ðŸŸ¡ High | 1 day |
| **5. Single bootstrap command** | Poor UX, multi-step setup | ðŸŸ¡ High | 1 day |
| **6. Hook templates** | Can't generate hooks automatically | ðŸŸ¡ High | 1-2 days |

---

## Implementation Plan

### Phase 1: Binary-Managed Hook Generation (Sprint 9A)

**Goal**: Binary creates and manages hook files automatically

**Effort**: 2-3 days

#### 1.1 Create Hook Template System

**File**: `src/huskycat/templates/hooks/pre-commit.template`

```bash
#!/usr/bin/env bash
# HuskyCat Pre-Commit Hook
# Auto-generated by huskycat v{{VERSION}}
# DO NOT EDIT - Regenerate with: huskycat setup-hooks --regenerate

set -e

# Detect execution mode
HUSKYCAT_BIN="{{BINARY_PATH}}"
if [[ -x "$HUSKYCAT_BIN" ]]; then
    # Binary mode (preferred)
    EXEC_CMD="$HUSKYCAT_BIN"
elif command -v huskycat &> /dev/null; then
    # Binary in PATH
    EXEC_CMD="huskycat"
elif command -v uv &> /dev/null && [[ -d ".venv" ]]; then
    # UV development mode (fallback)
    EXEC_CMD="uv run python -m src.huskycat"
else
    echo "Error: No HuskyCat installation found"
    echo "Install with: huskycat install"
    exit 1
fi

# Run validation
$EXEC_CMD validate --staged {{GITOPS_FLAGS}}

exit $?
```

**File**: `src/huskycat/templates/hooks/pre-push.template`

```bash
#!/usr/bin/env bash
# HuskyCat Pre-Push Hook
# Auto-generated by huskycat v{{VERSION}}
# DO NOT EDIT - Regenerate with: huskycat setup-hooks --regenerate

set -e

# Detect execution mode (same as pre-commit)
HUSKYCAT_BIN="{{BINARY_PATH}}"
if [[ -x "$HUSKYCAT_BIN" ]]; then
    EXEC_CMD="$HUSKYCAT_BIN"
elif command -v huskycat &> /dev/null; then
    EXEC_CMD="huskycat"
elif command -v uv &> /dev/null && [[ -d ".venv" ]]; then
    EXEC_CMD="uv run python -m src.huskycat"
else
    echo "Error: No HuskyCat installation found"
    exit 1
fi

# GitLab CI validation (if exists)
if [[ -f ".gitlab-ci.yml" ]]; then
    echo "Validating GitLab CI configuration..."
    $EXEC_CMD ci-validate .gitlab-ci.yml || exit $?
fi

{{#if GITOPS_ENABLED}}
# Auto-DevOps validation (if GitOps repo detected)
if [[ -d "chart" ]] || [[ -d "charts" ]] || [[ -d "k8s" ]] || [[ -d "kubernetes" ]]; then
    echo "Validating Auto-DevOps/K8s manifests..."
    $EXEC_CMD auto-devops --fast || exit $?
fi
{{/if}}

exit 0
```

#### 1.2 Implement Template Rendering

**File**: `src/huskycat/core/hook_generator.py` (NEW)

```python
"""Git hook generation and management."""
from pathlib import Path
from typing import Optional, Dict, Any
import os
import stat
import subprocess

class HookGenerator:
    """Generates and manages git hooks for HuskyCat."""

    HOOK_TEMPLATES = {
        "pre-commit": "templates/hooks/pre-commit.template",
        "pre-push": "templates/hooks/pre-push.template",
        "commit-msg": "templates/hooks/commit-msg.template",
    }

    def __init__(self, repo_path: Path, binary_path: Optional[Path] = None):
        self.repo_path = repo_path
        self.binary_path = binary_path or self._detect_binary_path()
        self.hooks_dir = repo_path / ".git" / "hooks"

    def _detect_binary_path(self) -> Optional[Path]:
        """Detect HuskyCat binary location."""
        # Check if running as PyInstaller binary
        if getattr(sys, 'frozen', False):
            return Path(sys.executable)

        # Check PATH
        which_result = subprocess.run(
            ["which", "huskycat"],
            capture_output=True,
            text=True
        )
        if which_result.returncode == 0:
            return Path(which_result.stdout.strip())

        return None

    def detect_repo_type(self) -> Dict[str, bool]:
        """Auto-detect repository type and features."""
        return {
            "gitlab_ci": (self.repo_path / ".gitlab-ci.yml").exists(),
            "github_actions": (self.repo_path / ".github" / "workflows").exists(),
            "helm_chart": any([
                (self.repo_path / "chart").exists(),
                (self.repo_path / "charts").exists(),
                (self.repo_path / ".helm").exists(),
            ]),
            "k8s_manifests": any([
                (self.repo_path / "k8s").exists(),
                (self.repo_path / "kubernetes").exists(),
                (self.repo_path / "manifests").exists(),
            ]),
            "terraform": bool(list(self.repo_path.glob("*.tf"))),
            "ansible": (self.repo_path / "playbooks").exists() or
                      (self.repo_path / "roles").exists(),
            "gitops": False,  # Set below
        }

    def is_gitops_repo(self, repo_info: Dict[str, bool]) -> bool:
        """Determine if this is a GitOps repository."""
        return any([
            repo_info["helm_chart"],
            repo_info["k8s_manifests"],
            repo_info["terraform"],
            repo_info["ansible"],
        ])

    def generate_hook(
        self,
        hook_name: str,
        template_vars: Optional[Dict[str, Any]] = None
    ) -> str:
        """Generate hook content from template."""
        template_path = Path(__file__).parent.parent / self.HOOK_TEMPLATES[hook_name]
        template = template_path.read_text()

        # Default variables
        vars = {
            "VERSION": "2.1.0",  # Get from __version__
            "BINARY_PATH": str(self.binary_path) if self.binary_path else "",
            "GITOPS_ENABLED": False,
            "GITOPS_FLAGS": "",
        }

        # Merge user variables
        if template_vars:
            vars.update(template_vars)

        # Simple template substitution
        content = template
        for key, value in vars.items():
            content = content.replace(f"{{{{%s}}}}" % key, str(value))

        return content

    def install_hook(self, hook_name: str, force: bool = False) -> bool:
        """Install a git hook."""
        hook_path = self.hooks_dir / hook_name

        # Check if hook exists
        if hook_path.exists() and not force:
            logger.warning(f"Hook {hook_name} already exists. Use --force to overwrite.")
            return False

        # Detect repo type
        repo_info = self.detect_repo_type()
        is_gitops = self.is_gitops_repo(repo_info)

        # Generate hook content
        template_vars = {
            "GITOPS_ENABLED": is_gitops,
            "GITOPS_FLAGS": "--gitops" if is_gitops else "",
        }
        content = self.generate_hook(hook_name, template_vars)

        # Write hook
        hook_path.write_text(content)

        # Make executable
        hook_path.chmod(hook_path.stat().st_mode | stat.S_IXUSR | stat.S_IXGRP | stat.S_IXOTH)

        logger.info(f"Installed {hook_name} hook")
        return True

    def install_all_hooks(self, force: bool = False) -> int:
        """Install all hooks."""
        count = 0
        for hook_name in self.HOOK_TEMPLATES.keys():
            if self.install_hook(hook_name, force):
                count += 1
        return count

    def update_hooks(self) -> int:
        """Update existing hooks to latest version."""
        count = 0
        for hook_name in self.HOOK_TEMPLATES.keys():
            hook_path = self.hooks_dir / hook_name
            if hook_path.exists() and "Auto-generated by huskycat" in hook_path.read_text():
                if self.install_hook(hook_name, force=True):
                    count += 1
        return count
```

#### 1.3 Update Setup-Hooks Command

**File**: `src/huskycat/commands/hooks.py` (UPDATE)

```python
def execute(self) -> int:
    """Set up git hooks using binary-managed hook generation."""
    repo_path = Path.cwd()

    # Detect if in git repo
    if not (repo_path / ".git").exists():
        logger.error("Not a git repository")
        return 1

    # Initialize hook generator
    generator = HookGenerator(repo_path)

    # Detect repo type
    repo_info = generator.detect_repo_type()
    is_gitops = generator.is_gitops_repo(repo_info)

    # Report findings
    logger.info("Repository analysis:")
    if repo_info["gitlab_ci"]:
        logger.info("  âœ“ GitLab CI detected (.gitlab-ci.yml)")
    if repo_info["helm_chart"]:
        logger.info("  âœ“ Helm chart detected")
    if repo_info["k8s_manifests"]:
        logger.info("  âœ“ Kubernetes manifests detected")
    if repo_info["terraform"]:
        logger.info("  âœ“ Terraform files detected")
    if repo_info["ansible"]:
        logger.info("  âœ“ Ansible playbooks detected")

    if is_gitops:
        logger.info("  â†’ GitOps repository detected!")
        logger.info("  â†’ Enabling Auto-DevOps validation in hooks")

    # Install hooks
    count = generator.install_all_hooks(force=self.args.force)
    logger.info(f"Installed {count} git hooks")

    # Instructions
    if generator.binary_path:
        logger.info(f"Hooks will use binary: {generator.binary_path}")
    else:
        logger.warning("Binary not found - hooks will use UV fallback")

    return 0
```

---

### Phase 2: Auto-DevOps in Git Hooks (Sprint 9A)

**Goal**: Add Auto-DevOps validation to pre-push hook for GitOps repos

**Effort**: 1 day

#### 2.1 Add --fast Flag to auto-devops Command

**File**: `src/huskycat/commands/autodevops.py` (UPDATE)

Add fast mode for git hooks (skip slow operations):

```python
def add_arguments(self, parser: argparse.ArgumentParser) -> None:
    """Add command arguments."""
    parser.add_argument("project_path", nargs="?", default=".", help="Path to project")
    parser.add_argument("--no-helm", action="store_true", help="Skip Helm validation")
    parser.add_argument("--no-k8s", action="store_true", help="Skip K8s validation")
    parser.add_argument("--simulate", action="store_true", help="Simulate deployment")
    parser.add_argument("--strict", action="store_true", help="Strict validation")
    parser.add_argument("--fast", action="store_true", help="Fast mode (skip slow checks)")  # NEW

def execute(self) -> int:
    """Execute Auto-DevOps validation."""
    # ... existing code ...

    if self.args.fast:
        # Skip slow operations in fast mode
        # - Skip helm template (requires downloading chart)
        # - Skip kubectl dry-run
        # - Only do schema validation
        logger.info("Fast mode enabled - skipping slow checks")
        skip_helm_template = True
        skip_kubectl = True
```

#### 2.2 Update Pre-Push Hook Template

Already included in Phase 1 templates above - the pre-push template includes:

```bash
# Auto-DevOps validation (if GitOps repo detected)
if [[ -d "chart" ]] || [[ -d "charts" ]] || [[ -d "k8s" ]] || [[ -d "kubernetes" ]]; then
    echo "Validating Auto-DevOps/K8s manifests..."
    $EXEC_CMD auto-devops --fast || exit $?
fi
```

---

### Phase 3: Single Bootstrap Command (Sprint 9A)

**Goal**: Implement `huskycat bootstrap` as single-command setup

**Effort**: 1 day

#### 3.1 Enhance Bootstrap Command

**File**: `src/huskycat/commands/bootstrap.py` (UPDATE or CREATE)

```python
"""Bootstrap command - one-command setup for GitOps/IaC repos."""
from pathlib import Path
import logging
from ..core.hook_generator import HookGenerator
from .install import InstallCommand
from .hooks import SetupHooksCommand

logger = logging.getLogger(__name__)

class BootstrapCommand:
    """Bootstrap HuskyCat in a repository."""

    name = "bootstrap"
    help = "Bootstrap HuskyCat with git hooks and GitOps validation"

    def __init__(self, args):
        self.args = args

    @staticmethod
    def add_arguments(parser):
        """Add command arguments."""
        parser.add_argument(
            "--skip-install",
            action="store_true",
            help="Skip binary installation (hooks only)"
        )
        parser.add_argument(
            "--force",
            action="store_true",
            help="Force overwrite existing hooks"
        )
        parser.add_argument(
            "--global",
            action="store_true",
            dest="global_install",
            help="Install binary globally to ~/.local/bin"
        )

    def execute(self) -> int:
        """Execute bootstrap."""
        logger.info(" Bootstrapping HuskyCat...")

        # Step 1: Install binary (if not skipped)
        if not self.args.skip_install:
            logger.info("Step 1: Installing binary...")
            install_cmd = InstallCommand(self.args)
            if install_cmd.execute() != 0:
                logger.error("Binary installation failed")
                return 1
        else:
            logger.info("Step 1: Skipping binary installation")

        # Step 2: Detect repository type
        logger.info("Step 2: Analyzing repository...")
        repo_path = Path.cwd()

        if not (repo_path / ".git").exists():
            logger.error("Not a git repository!")
            logger.info("Hint: Run 'git init' first")
            return 1

        generator = HookGenerator(repo_path)
        repo_info = generator.detect_repo_type()
        is_gitops = generator.is_gitops_repo(repo_info)

        # Report findings
        self._report_repo_info(repo_info, is_gitops)

        # Step 3: Set up git hooks
        logger.info("Step 3: Setting up git hooks...")
        hooks_cmd = SetupHooksCommand(self.args)
        if hooks_cmd.execute() != 0:
            logger.error("Hook setup failed")
            return 1

        # Step 4: Success message
        logger.info("")
        logger.info(" Bootstrap complete!")
        logger.info("")
        logger.info("HuskyCat is now configured for:")
        if repo_info["gitlab_ci"]:
            logger.info("  âœ“ GitLab CI validation (pre-push)")
        if is_gitops:
            logger.info("  âœ“ Auto-DevOps validation (pre-push)")
            if repo_info["helm_chart"]:
                logger.info("    - Helm chart validation")
            if repo_info["k8s_manifests"]:
                logger.info("    - Kubernetes manifest validation")
        if repo_info["terraform"]:
            logger.info("  âœ“ Terraform formatting (pre-commit)")
        if repo_info["ansible"]:
            logger.info("  âœ“ Ansible linting (pre-commit)")

        logger.info("")
        logger.info("Try it out:")
        logger.info("  git add . && git commit -m 'test: HuskyCat validation'")

        return 0

    def _report_repo_info(self, repo_info: dict, is_gitops: bool):
        """Report repository analysis findings."""
        logger.info("")
        logger.info("Repository type detection:")

        features = []
        if repo_info["gitlab_ci"]:
            features.append("GitLab CI")
        if repo_info["github_actions"]:
            features.append("GitHub Actions")
        if repo_info["helm_chart"]:
            features.append("Helm")
        if repo_info["k8s_manifests"]:
            features.append("Kubernetes")
        if repo_info["terraform"]:
            features.append("Terraform")
        if repo_info["ansible"]:
            features.append("Ansible")

        if features:
            logger.info(f"  Detected: {', '.join(features)}")
        else:
            logger.info("  No special features detected (standard code repo)")

        if is_gitops:
            logger.info("   GitOps repository - enabling IaC validation!")

        logger.info("")
```

#### 3.2 Update CLI Help Text

**File**: `src/huskycat/__main__.py` (UPDATE)

Update help text to promote `bootstrap` command:

```python
parser = argparse.ArgumentParser(
    description="HuskyCat - Universal Code Validation Platform",
    epilog="""
Quick Start:
  huskycat bootstrap              Bootstrap in current repository (one command!)
  huskycat install                Install binary to ~/.local/bin
  huskycat validate --staged      Validate staged files
  huskycat ci-validate            Validate GitLab CI configuration
  huskycat auto-devops            Validate Auto-DevOps/K8s manifests

For GitOps repositories, use 'huskycat bootstrap' for automatic setup!
"""
)
```

---

### Phase 4: Binary Hook Update Mechanism (Sprint 9B)

**Goal**: Binary automatically updates hooks when version changes

**Effort**: 1-2 days

#### 4.1 Add Version Tracking to Hooks

Hooks already have version in template:
```bash
# Auto-generated by huskycat v{{VERSION}}
```

#### 4.2 Add Hook Update Check

**File**: `src/huskycat/commands/hooks.py` (UPDATE)

```python
def check_hooks_version(self) -> Optional[str]:
    """Check if hooks need updating."""
    repo_path = Path.cwd()
    hooks_dir = repo_path / ".git" / "hooks"
    pre_commit = hooks_dir / "pre-commit"

    if not pre_commit.exists():
        return None

    content = pre_commit.read_text()

    # Extract version from hook
    import re
    match = re.search(r"# Auto-generated by huskycat v([\d.]+)", content)
    if not match:
        return None  # Not a HuskyCat-generated hook

    hook_version = match.group(1)
    current_version = __version__  # e.g., "2.1.0"

    if hook_version != current_version:
        return hook_version  # Outdated

    return None  # Up to date

def maybe_update_hooks(self) -> bool:
    """Auto-update hooks if outdated."""
    old_version = self.check_hooks_version()

    if old_version:
        logger.info(f"Hooks are outdated (v{old_version}), updating to v{__version__}...")
        generator = HookGenerator(Path.cwd())
        count = generator.update_hooks()
        logger.info(f"Updated {count} hooks")
        return True

    return False
```

#### 4.3 Add Auto-Update on Commands

**File**: `src/huskycat/__main__.py` (UPDATE)

Add hook update check before running commands:

```python
def main():
    """Main entry point."""
    args = parser.parse_args()

    # Auto-update hooks if needed (only in git repos)
    if (Path.cwd() / ".git").exists():
        from .commands.hooks import SetupHooksCommand
        hooks_cmd = SetupHooksCommand(args)
        hooks_cmd.maybe_update_hooks()

    # ... rest of main() ...
```

---

### Phase 5: Documentation & Testing (Sprint 9B)

**Goal**: Document new GitOps bootstrap flow and test thoroughly

**Effort**: 1 day

#### 5.1 Create GitOps Bootstrap Guide

**File**: `docs/gitops-bootstrap-guide.md` (NEW)

```markdown
# GitOps Bootstrap Guide

## Quick Start

### 1. Install Binary

Download the latest HuskyCat binary for your platform:

\`\`\`bash
# Linux AMD64
curl -L -o ~/.local/bin/huskycat \\
  https://gitlab.com/tinyland/ai/huskycat/-/releases/permalink/latest/downloads/huskycat-linux-amd64
chmod +x ~/.local/bin/huskycat

# Linux ARM64
curl -L -o ~/.local/bin/huskycat \\
  https://gitlab.com/tinyland/ai/huskycat/-/releases/permalink/latest/downloads/huskycat-linux-arm64
chmod +x ~/.local/bin/huskycat

# macOS ARM64 (Apple Silicon)
curl -L -o ~/.local/bin/huskycat \\
  https://gitlab.com/tinyland/ai/huskycat/-/releases/permalink/latest/downloads/huskycat-macos-arm64
chmod +x ~/.local/bin/huskycat
\`\`\`

### 2. Bootstrap Your Repository

Navigate to your GitOps repository and run:

\`\`\`bash
cd /path/to/your/gitops-repo
huskycat bootstrap
\`\`\`

That's it! HuskyCat will:
-  Detect your repository type (GitLab CI, Helm, K8s, Terraform, Ansible)
-  Install git hooks automatically
-  Enable appropriate validations based on detected features
-  Configure pre-commit and pre-push hooks

### 3. Verify Setup

Try making a commit:

\`\`\`bash
echo "test" >> README.md
git add README.md
git commit -m "test: verify HuskyCat hooks"
\`\`\`

You should see HuskyCat validation output!

## What Gets Validated?

### Pre-Commit Hook (Staged Files)

- **Python**: Black, Ruff, IsSort, Flake8, MyPy
- **JavaScript/TypeScript**: Prettier, ESLint
- **Terraform**: `terraform fmt` auto-formatting
- **Ansible**: ansible-lint with auto-fix
- **TOML**: taplo formatting
- **YAML**: yamllint
- **Shell**: shellcheck
- **Docker**: hadolint

### Pre-Push Hook (Fast CI Checks)

- **GitLab CI**: Schema validation (`.gitlab-ci.yml`)
- **Auto-DevOps** (if GitOps repo detected):
  - Helm chart validation
  - Kubernetes manifest validation
  - Auto-DevOps compliance checking

## Repository Detection

HuskyCat automatically detects your repository type:

| Feature | Detection | Hook Behavior |
|---------|-----------|---------------|
| **GitLab CI** | `.gitlab-ci.yml` exists | Validates CI config on pre-push |
| **Helm Charts** | `chart/`, `charts/`, `.helm/` dirs | Validates charts on pre-push |
| **K8s Manifests** | `k8s/`, `kubernetes/`, `manifests/` dirs | Validates manifests on pre-push |
| **Terraform** | `*.tf` files | Formats on pre-commit |
| **Ansible** | `playbooks/`, `roles/` dirs | Lints on pre-commit |

## Advanced Usage

### Force Reinstall Hooks

\`\`\`bash
huskycat setup-hooks --force
\`\`\`

### Skip GitOps Validation (Temporary)

\`\`\`bash
SKIP_GITOPS=1 git push
\`\`\`

### Skip All Hooks (Emergency)

\`\`\`bash
git commit --no-verify
git push --no-verify
\`\`\`

### Update Hooks After Binary Update

Hooks are automatically updated when you run any HuskyCat command. But you can force update:

\`\`\`bash
huskycat setup-hooks --regenerate
\`\`\`

## Troubleshooting

### Hooks Not Running

1. Check hook files exist:
   \`\`\`bash
   ls -la .git/hooks/
   \`\`\`

2. Verify hooks are executable:
   \`\`\`bash
   chmod +x .git/hooks/pre-commit
   chmod +x .git/hooks/pre-push
   \`\`\`

3. Regenerate hooks:
   \`\`\`bash
   huskycat setup-hooks --force
   \`\`\`

### Binary Not Found in Hooks

Hooks auto-detect binary location. If binary moved:

\`\`\`bash
# Regenerate hooks with new binary location
huskycat setup-hooks --force
\`\`\`

### Validation Too Slow

For GitOps repos with many manifests:

\`\`\`bash
# Disable Auto-DevOps validation in pre-push
# Edit .git/hooks/pre-push and comment out auto-devops section
\`\`\`

## Package Manager Installation (Future)

HuskyCat will soon be available via package managers:

\`\`\`bash
# Arch Linux (AUR)
yay -S huskycat

# Homebrew (macOS/Linux)
brew install huskycat

# apt (Debian/Ubuntu)
sudo apt install huskycat

# dnf (Fedora/RHEL)
sudo dnf install huskycat
\`\`\`

After installation:
\`\`\`bash
cd /path/to/repo
huskycat bootstrap
\`\`\`
```

#### 5.2 Update Main Documentation

Update `docs/index.md`, `docs/installation.md`, and `README.md` with GitOps bootstrap flow.

#### 5.3 Create Test Plan

**File**: `docs/proposals/gitops-bootstrap-test-plan.md`

Test matrix:
- Test on fresh GitLab CI repo
- Test on Helm chart repo
- Test on Terraform repo
- Test on mixed GitOps repo
- Test binary updates
- Test on non-GitOps repo (should work but not enable GitOps features)

---

## Implementation Timeline

### Sprint 9A (Week 1): Core Features
- **Days 1-2**: Binary-managed hook generation (Phase 1)
- **Day 3**: Auto-DevOps in hooks (Phase 2)
- **Day 4**: Single bootstrap command (Phase 3)
- **Day 5**: Testing and bug fixes

### Sprint 9B (Week 2): Polish & Documentation
- **Days 1-2**: Binary hook update mechanism (Phase 4)
- **Day 3**: Documentation (Phase 5)
- **Days 4-5**: Integration testing and refinement

**Total Effort**: 8-10 days

---

## Success Criteria

### Must Have 
1.  `huskycat bootstrap` works in one command
2.  Hooks auto-detect GitOps repo type
3.  Auto-DevOps validation runs in pre-push for GitOps repos
4.  Binary manages hook files (creates and updates)
5.  Hooks prefer binary, fall back to UV
6.  Hooks auto-update when binary version changes

### Should Have ðŸŸ¡
7. ðŸŸ¡ Comprehensive GitOps bootstrap documentation
8. ðŸŸ¡ Test coverage for bootstrap flow
9. ðŸŸ¡ Error messages guide users to fix issues
10. ðŸŸ¡ `--fast` mode for auto-devops in hooks

### Nice to Have ðŸ”µ
11. ðŸ”µ Package manager installations (AUR, Homebrew, apt, dnf)
12. ðŸ”µ Shell completions for `bootstrap` command
13. ðŸ”µ `huskycat doctor` command to diagnose hook issues

---

## Breaking Changes & Migration

### For Existing Users (HuskyCat Repo Itself)

**Current State**: Uses UV-based hooks
**New State**: Can use binary-based hooks

**Migration Path**:
1. Keep UV-based hooks for dogfooding (development)
2. Provide binary-based hooks as alternative
3. Document both approaches

**Recommendation**: Keep `.githooks/` as UV-based for HuskyCat development, but generate binary-based hooks in `.git/hooks/` for testing.

### For External Users

**No breaking changes** - this is all new functionality!

---

## Open Questions

1. **Hook collision**: What if user already has hooks in `.git/hooks/`?
   - **Answer**: Add `--force` flag to overwrite, otherwise warn and skip

2. **Multiple hook managers**: What if user uses husky, lint-staged, etc.?
   - **Answer**: Detect and warn, don't overwrite

3. **Hook customization**: How can users customize generated hooks?
   - **Answer**: Provide `.huskycat.yaml` config in Phase 2 (Sprint 9 or 10)

4. **Dogfooding paradox**: How to test binary-based hooks in HuskyCat repo?
   - **Answer**:
     - Keep `.githooks/` as UV-based (for git config core.hooksPath)
     - Generate binary hooks to `.git/hooks/` for testing
     - Test binary hooks in external test repos

---

## Risks & Mitigation

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| Hook collision with existing tools | Medium | High | Detect and warn, require --force |
| Binary not in PATH | Medium | High | Auto-detect, provide clear error messages |
| Template rendering bugs | Low | Medium | Comprehensive testing, fallback to UV |
| Version mismatch issues | Low | High | Clear version tracking, auto-update |
| Performance regression | Low | Medium | Keep --fast mode, optimize auto-devops |

---

## Conclusion

This implementation plan provides a **seamless GitOps bootstrap experience** with:
-  **Single command**: `huskycat bootstrap`
-  **Auto-detection**: Recognizes GitOps repos automatically
-  **Binary-managed hooks**: Binary creates and updates hooks
-  **Comprehensive validation**: GitLab CI, Auto-DevOps, Helm, K8s, Terraform, Ansible
-  **Smart fallback**: Binary â†’ PATH â†’ UV
-  **Auto-updates**: Hooks update when binary version changes

**Next Steps**:
1. Review and approve plan
2. Begin Sprint 9A implementation
3. Test on real GitOps repositories
4. Iterate based on feedback

---

**Plan Status**:  Ready for Review
**Approval Needed**: Yes
**Target Sprint**: Sprint 9 (Post Sprint 8 Completion)
**Estimated Effort**: 8-10 days
