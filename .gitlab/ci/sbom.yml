# SPDX-License-Identifier: Apache-2.0
# SBOM Generation and Vulnerability Scanning Pipeline
#
# Generates Software Bill of Materials (SBOM) using Syft and scans for
# vulnerabilities using Grype. Signs SBOM with Cosign for integrity verification.
#
# Outputs:
# - CycloneDX 1.5 SBOM (security-focused, OWASP standard)
# - SPDX 2.3 SBOM (compliance-focused)
# - Vulnerability report
# - Signed SBOM with Sigstore
#
# Usage:
#   include:
#     - local: '/.gitlab/ci/sbom.yml'

variables:
  SYFT_VERSION: "1.0.1"
  GRYPE_VERSION: "0.74.0"
  COSIGN_VERSION: "2.2.3"
  SBOM_FORMAT: "cyclonedx-json"
  VULN_FAIL_ON: "critical"  # Fail on critical vulnerabilities

# SBOM generation from source
sbom:generate:source:
  stage: security
  image: alpine:3.19
  needs: []
  retry:
    max: 2
    when:
      - runner_system_failure
      - stuck_or_timeout_failure
      - script_failure
  before_script:
    - apk add --no-cache curl bash python3 py3-pip
    # Install Syft with retry
    - |
      for i in 1 2 3; do
        curl -sSfL https://raw.githubusercontent.com/anchore/syft/main/install.sh | \
          sh -s -- -b /usr/local/bin v${SYFT_VERSION} && break
        echo "Retry $i..."
        sleep 5
      done
    - syft version
  script:
    - echo "üìã Generating SBOM from source..."

    # Generate SBOM from source directory (Python project)
    - syft dir:. -o cyclonedx-json=sbom-source-cyclonedx.json
    - syft dir:. -o spdx-json=sbom-source-spdx.json

    # Generate SBOM from Python dependencies
    - |
      if [ -f pyproject.toml ]; then
        syft file:pyproject.toml -o cyclonedx-json=sbom-python-deps.json
      fi

    # Verify SBOM is valid JSON
    - python3 -c "import json; json.load(open('sbom-source-cyclonedx.json'))"

    - echo "‚úÖ SBOM generation complete"
    - ls -la sbom-*.json
  artifacts:
    paths:
      - sbom-source-cyclonedx.json
      - sbom-source-spdx.json
      - sbom-python-deps.json
    reports:
      cyclonedx: sbom-source-cyclonedx.json
    expire_in: 1 month
  rules:
    - if: $CI_COMMIT_TAG
    - if: $CI_COMMIT_BRANCH == "main"
    - if: $CI_PIPELINE_SOURCE == "schedule"

# SBOM generation from container image
sbom:generate:container:
  stage: security
  image: alpine:3.19
  needs:
    - job: container:build:amd64
      artifacts: false
  before_script:
    - apk add --no-cache curl bash skopeo
    # Install Syft
    - |
      curl -sSfL https://raw.githubusercontent.com/anchore/syft/main/install.sh | \
        sh -s -- -b /usr/local/bin v${SYFT_VERSION}
    - syft version
  script:
    - echo "üìã Generating SBOM from container image..."

    # Generate SBOM from container registry
    - |
      syft registry:${CONTAINER_REGISTRY}:${CONTAINER_TAG}-amd64 \
        -o cyclonedx-json=sbom-container-cyclonedx.json \
        -o spdx-json=sbom-container-spdx.json

    - echo "‚úÖ Container SBOM generation complete"
    - ls -la sbom-*.json
  artifacts:
    paths:
      - sbom-container-cyclonedx.json
      - sbom-container-spdx.json
    reports:
      cyclonedx: sbom-container-cyclonedx.json
    expire_in: 1 month
  rules:
    - if: $CI_COMMIT_TAG
    - if: $CI_COMMIT_BRANCH == "main"

# Vulnerability scanning with Grype
sbom:vuln-scan:
  stage: security
  image: alpine:3.19
  needs:
    - job: sbom:generate:source
      artifacts: true
  before_script:
    - apk add --no-cache curl bash jq
    # Install Grype
    - |
      curl -sSfL https://raw.githubusercontent.com/anchore/grype/main/install.sh | \
        sh -s -- -b /usr/local/bin v${GRYPE_VERSION}
    - grype version
    # Update vulnerability database
    - grype db update
  script:
    - echo "üîç Scanning SBOM for vulnerabilities..."

    # Scan SBOM for vulnerabilities
    - grype sbom:sbom-source-cyclonedx.json -o json > vulnerabilities.json
    - grype sbom:sbom-source-cyclonedx.json -o table > vulnerabilities.txt

    # Display summary
    - echo "=== Vulnerability Summary ==="
    - cat vulnerabilities.txt

    # Count by severity
    - |
      echo "=== By Severity ==="
      jq -r '.matches | group_by(.vulnerability.severity) | map({severity: .[0].vulnerability.severity, count: length}) | .[]' vulnerabilities.json || true

    # Fail on critical vulnerabilities (optional)
    - |
      CRITICAL_COUNT=$(jq '[.matches[] | select(.vulnerability.severity == "Critical")] | length' vulnerabilities.json)
      if [ "$CRITICAL_COUNT" -gt 0 ] && [ "$VULN_FAIL_ON" = "critical" ]; then
        echo "‚ö†Ô∏è  Found $CRITICAL_COUNT critical vulnerabilities"
        # Uncomment to fail pipeline:
        # exit 1
      fi

    - echo "‚úÖ Vulnerability scan complete"
  artifacts:
    paths:
      - vulnerabilities.json
      - vulnerabilities.txt
    reports:
      cyclonedx: sbom-source-cyclonedx.json
    expire_in: 1 month
  rules:
    - if: $CI_COMMIT_TAG
    - if: $CI_COMMIT_BRANCH == "main"
    - if: $CI_PIPELINE_SOURCE == "schedule"

# Sign SBOM with Cosign (keyless via Sigstore)
sbom:sign:
  stage: deploy
  image: alpine:3.19
  needs:
    - job: sbom:generate:source
      artifacts: true
    - job: sbom:vuln-scan
      artifacts: true
  before_script:
    - apk add --no-cache curl bash
    # Install Cosign
    - |
      curl -LO https://github.com/sigstore/cosign/releases/download/v${COSIGN_VERSION}/cosign-linux-amd64
      chmod +x cosign-linux-amd64
      mv cosign-linux-amd64 /usr/local/bin/cosign
    - cosign version
  script:
    - echo "üîè Signing SBOM with Cosign..."

    # Sign SBOM with keyless signing (Sigstore)
    # Note: Requires OIDC token for CI (GitLab provides this)
    - |
      if [ -n "$CI_JOB_JWT_V2" ]; then
        echo "Using GitLab OIDC token for keyless signing..."
        COSIGN_EXPERIMENTAL=1 cosign sign-blob \
          --yes \
          --oidc-issuer https://gitlab.com \
          --oidc-provider gitlab \
          --output-signature sbom-source-cyclonedx.json.sig \
          --output-certificate sbom-source-cyclonedx.json.cert \
          sbom-source-cyclonedx.json

        # Verify signature
        COSIGN_EXPERIMENTAL=1 cosign verify-blob \
          --certificate sbom-source-cyclonedx.json.cert \
          --signature sbom-source-cyclonedx.json.sig \
          --certificate-identity-regexp ".*" \
          --certificate-oidc-issuer-regexp "https://gitlab.com" \
          sbom-source-cyclonedx.json

        echo "‚úÖ SBOM signature verified"
      else
        echo "‚ö†Ô∏è  OIDC token not available, skipping signing"
      fi
  artifacts:
    paths:
      - sbom-source-cyclonedx.json
      - sbom-source-cyclonedx.json.sig
      - sbom-source-cyclonedx.json.cert
      - vulnerabilities.json
    expire_in: 1 month
  rules:
    - if: $CI_COMMIT_TAG

# Merge SBOMs for comprehensive view
sbom:merge:
  stage: deploy
  image: python:3.11-alpine
  needs:
    - job: sbom:generate:source
      artifacts: true
    - job: sbom:generate:container
      artifacts: true
      optional: true
  script:
    - echo "üìã Merging SBOMs..."
    - pip install --no-cache-dir cyclonedx-bom

    # Merge source and container SBOMs
    - |
      python3 << 'EOF'
      import json
      from pathlib import Path

      # Load source SBOM
      with open('sbom-source-cyclonedx.json') as f:
          merged = json.load(f)

      # Merge container SBOM if exists
      container_sbom = Path('sbom-container-cyclonedx.json')
      if container_sbom.exists():
          with open(container_sbom) as f:
              container = json.load(f)
          # Add container components
          merged.setdefault('components', []).extend(
              container.get('components', [])
          )
          # Deduplicate by purl
          seen_purls = set()
          unique_components = []
          for comp in merged.get('components', []):
              purl = comp.get('purl', comp.get('name', ''))
              if purl not in seen_purls:
                  seen_purls.add(purl)
                  unique_components.append(comp)
          merged['components'] = unique_components

      with open('sbom-merged.json', 'w') as f:
          json.dump(merged, f, indent=2)

      print(f"Merged SBOM: {len(merged.get('components', []))} components")
      EOF

    - echo "‚úÖ SBOM merge complete"
  artifacts:
    paths:
      - sbom-merged.json
    reports:
      cyclonedx: sbom-merged.json
    expire_in: 1 month
  rules:
    - if: $CI_COMMIT_TAG
    - if: $CI_COMMIT_BRANCH == "main"

# License compliance check
sbom:license-check:
  stage: security
  image: python:3.11-alpine
  needs:
    - job: sbom:generate:source
      artifacts: true
  script:
    - echo "‚öñÔ∏è  Checking license compliance..."
    - pip install --no-cache-dir pip-licenses

    # Extract and analyze licenses from SBOM
    - |
      python3 << 'EOF'
      import json

      # GPL-incompatible licenses for Apache-2.0 distribution
      FORBIDDEN_LICENSES = {
          'GPL-3.0-only', 'GPL-3.0-or-later', 'GPL-2.0-only', 'GPL-2.0-or-later',
          'AGPL-3.0-only', 'AGPL-3.0-or-later', 'LGPL-2.1-only', 'LGPL-3.0-only'
      }

      # Warn but don't fail
      WARNING_LICENSES = {
          'LGPL-2.1-or-later', 'LGPL-3.0-or-later', 'MPL-2.0'
      }

      with open('sbom-source-cyclonedx.json') as f:
          sbom = json.load(f)

      violations = []
      warnings = []

      for component in sbom.get('components', []):
          name = component.get('name', 'unknown')
          for license_info in component.get('licenses', []):
              license_id = license_info.get('license', {}).get('id', '')
              if license_id in FORBIDDEN_LICENSES:
                  violations.append(f"{name}: {license_id}")
              elif license_id in WARNING_LICENSES:
                  warnings.append(f"{name}: {license_id}")

      if violations:
          print("‚ùå GPL/AGPL components found (bundling forbidden):")
          for v in violations:
              print(f"  - {v}")
          print("\nThese must be container-only or removed from binary")
          # exit(1)  # Uncomment to fail pipeline

      if warnings:
          print("\n‚ö†Ô∏è  Copyleft components (review required):")
          for w in warnings:
              print(f"  - {w}")

      if not violations and not warnings:
          print("‚úÖ All licenses compatible with Apache-2.0")
      EOF
  artifacts:
    paths:
      - license-report.txt
    expire_in: 1 month
  allow_failure: true
  rules:
    - if: $CI_COMMIT_TAG
    - if: $CI_COMMIT_BRANCH == "main"
    - if: $CI_PIPELINE_SOURCE == "schedule"
