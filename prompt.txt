
success metrics:  one line install script live on mkdocs page to install prebuilt huskycats into any repo, automatically setting up all the local githooks, dot files etc that call the prebuilt container with the appropriate architecure locally and install that container, all one line using the huskycat container buitl and registered via CI.  the locally intalled huskycat binary (UPX packed) that was installed to the root of the user's following the one line install ships with a working stdio MCP server for all the container's validation tools for agenting use.

Start by deeply researching our docs and prior attempts with research subagent.   Our goal is to work slowly, methodically and use our tooling to help guide our coding and debugging and testing lifecycle; compilation errors are expected, this is part of the debugging and validation process.  Never comment out failing components; a failure means you need to spawn a researcher or subagent to analyze and trace the failure.

When it comes to our package.json scripts and entrypoint code, lets further cleanup and architecturally analyze (using our actual huskycats hooks and local container, you'll need to research and build a new container as our readme and docs describes and try to use the MCP tooling, container and githooks to verify our own repo).   we likely do not want root level shell scripts and misc. python files, we want a clean, publication ready repo experince.  similarly, we want the package.json and structure to mean lean, clear and well laid out.

We'll then proceed to setting up a robust and beautiful mkdocs gitlab pages deployment setup that includes our setup readme instructions for for one liner setup and installation, MCP server setup for claude code and shall include dynamic container, package, script, binary artifact downloads, available via the pages site directly from teh artifactory features of gitlab.  use glab to motinor and architect this.   err on the side of stability and cleanlkiness, avoiding making bold claims.  simplify and focus on the technical requirements to get the deployments and gitlab builds working to make this work.


#### general guiding notes:

Never write new files with "-v2", "-enhanced", "-new" etc.  always use proper semantics and file naming protocols.  if you find duplicative or unclear file or function naming, fix it.

Leverage subagents and our discovered testing suites to actively test, lint, and operate with inline assertions and PBT driven development asw you develop through the goals listed below.

Always build / redeploy our applications and deliverables with nohup and a dated log file in the logs/ directory; use timed agents to check on logs and use notify and the claude-flow MCP to communicate discoveries.  never ever write code without testing it.

There should be NO Dockerfiles or docker-compose semantics, we ONLY should use ContainerFile and podman-compose if OCI containers are ever used.

Never write new files unless absolutely needed.  Do not write new files without first reading adjacent files for context or existing implementations.

Please write docs as you go in docs/ directory in mkdocs.yml friendly format.

# Python:
All our Python code should use UV package manager.  All python code should follow a proper packable factory pattern.  We use inline assertions and PBT with hypothesis for writing code.  We leverage pytest and playwright.  tests go in tests/.


